Following the Udemy malDev course...

Download win10.ova from https://ln4.sync.com/dl/a67c3e0c0/ffdqygsf-cqxicvmb-3ki9ehrj-gcsfszkg/view/default/11890955400008


PE files:
    Portable executable
        Structure: headers + sections... => metadata + data (https://github.com/corkami/pics/blob/master/binary/pe101/README.md)

        use pe bear to load exe files and see that structure - most important things: .rtext, .rdata, .rsrc
        or use dumpbin in cli: $ dumpbin /headers c:\windows\system32\calc.exe 




    Generating exe vc dll:
        exe vs dynamic-link library 
        

        $ rundll32 implant.dll,RunME

        use Proces Hacker to see the running processes 


Droppers:

    Program that will deliver the payload to a victim

    can be javascript, powershell (or even .exe)

    Where to store the payload?
        1) .text - put the payload into main function (02.Payload_Storage/01.implant.text)
        2) .data - read only -> create a global variable holding the payload (02.Payload_Storage/01.implant.data)
        3) .rsrc - create a small file that holds the payload 
                    -> tell the compiler that theat file is the part of the resources section 
                    -> use specific API calls that extracts the payload (02.Payload_Storage/01.implant.rsrc)



Obfuscation and hiding:
    Why use it? 
        to hide from AV from binary maching / easy string patterns

    Encoders: Base64 (03.Payload_Encoding/implant.cpp)
        $ cartutil -encode calc.bin calc.b64 -> past that in unsigned char calc_payload[] = "" and get rid of '/n'
        Not enough to avoid detection - its too popular (use your own algorithm)

    Encryptions: AES, XOR
        XOR:  
            xorencrypt.py calc.bin -> copy the contents in payload
            
        AES:
            aesencrypt.py calc.bin -> copy the contents in payload and key 

    Function call Obfuscation:
        method of hiding DLLs or external functions - use GitModuleHandle and getProcAddress functions

            handle = GetmoduleHandle("sound.dll")
            GetProcAddress(handle, "PlaySound")

            lets get rid of dll functions in 05.Functions_Obfuscation/oldImplant.cpp
                and lets encrypt "VirtualProtect"
                c:\Python27\python.exe -i xorencrypt2.py
                >>> printC(xor("VirtualProtect", "ysgadlewneahOASUDNA"))
                { 0x2f, 0x1a, 0x15, 0x15, 0x11, 0xd, 0x9, 0x27, 0x1c, 0xa, 0x15, 0xd, 0x2c, 0x35 };

            to check that the program doesnot use virtualprotect
                $ c:\rto\tools\si\strings.exe -n 8 implant.exe | findstr /i "virtual"


Backdoors and trojan

    methods of implanting
        1) Code cave - spare space in a PE file (usually in .text space) that is not occupied by other data (just a few handred bytes of free space - enough for mid size shell code) 
        2) NewSection - add new section and set the size to anything you want - downsize: you have to set this section as executable (easily caught by an AV)
        3) Expand a section 
        4) Combine few of these methods 

    lets do this to a Putty program:
        1. put the program into a debugger to find the code cave address (breakpoint -> entry point -> find 0000 0000 ...): 0045C961
        2. create a jump to our code cave and then jump back to the original code

00454AD0 | 6A 60                    | push 60                                 |
00454AD2 | 68 B07A4700              | push putty.477AB0                       |
00454AD7 | E8 08210000              | call putty.456BE4                       |
00454ADC | BF 94000000              | mov edi,94                              | edi:"LdrpInitializeProcess"
00454AE1 | 8BC7                     | mov eax,edi                             | edi:"LdrpInitializeProcess"

        3. assemble: jmp to our address: 0x0045C961
        4. lets copy the shellcode to out code cave
            pushad
            pushfd
            past the shellcode (leave the last line as is - we will need it to jump back to the original program): binary -> edit -> ctrl+v 
        5. search for the termination call in our shellcode 
            0045CA16 | 6A 00                    | push 0                                  |
            0045CA18 | 53                       | push ebx                                |
            0045CA19 | FFD5                     | call ebp                                |
        6. jump over it (create a jump from 0045CA16 to some address with 0000 instructions) and restore the original call for the putty program
            popfd
            popad


00454AD0 | 6A 60                    | push 60                                 |
00454AD2 | 68 B07A4700              | push putty.477AB0                       |

            edit binary with this: 6A 60 68 B0 7A 47 00
            jump to the putty call: 00454AD7
        7. ctrl + P to patch the file and thats it! 



Code injection 
    
    Transfering a payload from one proces to another 
        Why? to excape short-lived process, change working context, backup connection session (TOON rule = Two is One, One is None)...

        Classic methods? 
            debugging win API
            DLL injection


    Payload injection
        using VirtualAllocEx, WriteProcessMemory, CreateRemoteThread...
            07.Code_Injection/01.Shellcode/implant.cpp

    DLL injection
        07.Code_Injection/02.DLL/injectDLL.cpp and 07.Code_Injection/02.DLL/implantDLL.cpp

            1. Get LoadLibrary address from out process using GetProcAddress
            2. we allocate the memory at the injection process using WirtualAllocEx
            3. we copy the path to the DLL with WriteProcessMemory
            4. call CreateRemoteThread with the address (from step 1) and the path (from step 3)

        
Hiding console (no console window pop-up)

    Freeconsole - the console is still visible but for a very short amount of time - 08.Hiding_Console/01.Freeconsole/implant.cpp 
    GUI trick - compiling a program as a gui program - 08.Hiding_Console/02.GUItrick/implant.cpp - 

    

ToDo: 
    import address table hooking
    migrate 32 and 64 bit processes
    reflective DLL injection
    .
    .
    .

